<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>第十五天知识点回顾</title>
		<link rel="stylesheet" type="text/css" href="../../css/biji.css"/>
		<link rel="shortcut icon" type="image/x-icon" href="../../img/biaoti.gif" />
		<style type="text/css">
			table {
					width: 870px;
					margin-left: 33px;
			      }
		</style>
	</head>
	<body>
		<div class="top1">
				<span class="top_span">章节目录</span><br />
				<a class="top_span" href="../../学习笔记入口.html">返回主页</a><br />
				<a class="top_span" href="#1">DOM-CSS样式操作</a> <br />
				<a class="top_span" href="#2">事件对象(event)</a> <br />
				<a class="top_span" href="#3">冒泡（Bubble）</a> <br />
		</div>
		<div id="bot1">
			<!--DOM方法开始-->
			<fieldset id="1">
				<legend>DOM-CSS样式操作</legend>
				<table>
					<tr><th>DOM-CSS样式操作</th></tr>
					<tr><td></td></tr>
					<tr><td>(1).通过js修改元素的样式：元素.style.属性样式 = 属性样式值</td></tr>
					<tr><td>&nbsp;&nbsp;注意事项：当是复合属性样式的时候，使用驼峰命名法来书写属性样式</td></tr>
					<tr><td>&nbsp;&nbsp;style 修改的样式都是元素的内联样式。如果在外联样式中设置属性样式的!important，则无法通过内联样式进行覆盖</td></tr>
					<tr><td>(2).获取属性样式值：元素.style.属性样式</td></tr>
					<tr><td>&nbsp;&nbsp;注意：此方法只能读取内联样式，如果没有内联样式则不能读取</td></tr>
					<tr><td>(3).currentStyle:获取当前生效的样式; 元素.currentStyle.属性样式</td></tr>
					<tr><td>&nbsp;&nbsp;注意：此方法只有IE浏览器支持，其他浏览器不支持</td></tr>
					<tr><td>(4).其他浏览器则使用getComputedStyle(对象，null).属性样式</td></tr>
					<tr><td>&nbsp;&nbsp;注意：此方法只要IE不支持</td></tr>
					<tr><td>currentStyle和getComputedStyle总结：这两种方法只能用于读取，不能用于赋值</td></tr>
					<tr><td></td></tr>
					<tr><td>(5).currentStyle和getComputedStyle结合使用：</td></tr>
					<tr><td>&nbsp;&nbsp;function getStyle(obj , Name){ //obj指需要获取的对象；Name属性样式名</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;return window.getComputedStyle ? getComputedStyle(obj,null)[Name] : obj.currentStyle[Name];</td></tr>
					<tr><td>&nbsp;&nbsp;}</td></tr>
					<tr><td>&nbsp;&nbsp;总结：这个函数主要用于判断获取对象的属性值的时候，通过判断浏览器是否含有对应的方法，从而获取样式的属性值</td></tr>
					<tr><td></td></tr>
					<tr><td>(6).获取样式的可见宽高： 宽 clientWidth；高 clientHeight；用法：对象.clientWidth 或 对象.clienHeight</td></tr>
					<tr><td>&nbsp;&nbsp;注意：可见宽高只包括元素的内容区域和内边距</td></tr>
					<tr><td>(7).获取元素的可见框大小：宽 offsetWidth；高 offsetHeight;用法：对象.offsetWidth 或 对象.offsetHeight</td></tr>
					<tr><td>&nbsp;&nbsp;注意:可见框的大小包括内容区域、内边距、边框</td></tr>
					<tr><td>(8).offsetparent:返回当前元素的定位父元素；对象.offsetparent</td></tr>
					<tr><td>&nbsp;&nbsp;注意：定位父元素值开启了定位的祖先元素</td></tr>
					<tr><td>(9).offsetTop:垂直偏移量；用法：对象.offsetTop</td></tr>
					<tr><td>(10).offsetLeft:水平偏移量；用法：对象.offsetLeft</td></tr>
					<tr><td>&nbsp;&nbsp;注意：偏移量是相对开启定位的祖先元素的偏移量。如果祖先元素都没有开启定位则相对于body</td></tr>
					<tr><td></td></tr>
					<tr><td>(11).获取元素滚动区域的大小：scrollWidth:获取元素滚动区域的宽度; scrollHeight:获取元素滚动区域的高度;</td></tr>
					<tr><td>(12).获取元素滚动区的距离： 水平距离：scrollLeft; 垂直距离： scrollTop；</td></tr>
					<tr><td>总结：当滚动区域大小-滚动区距离=元素的可见大小，则滚动条到底了</td></tr>
					<tr><td>&nbsp;&nbsp;scrollWidth - scrollLeft = clientWidth</td></tr>
					<tr><td>&nbsp;&nbsp;scrollHeight - scrollTop = clientHeight</td></tr>
					<tr><td></td></tr>
					<tr><td>(14).鼠标拖动滚动条监听事件：onscroll</td></tr>
					<tr><td>(15).鼠标拖进入指定区域监听事件：onmousemove</td></tr>
					<tr><td>应用场景：合同协议是否阅读。</td></tr>
					<tr><td>案例：<a href="../../实战项目/课堂练习/滚动样式的练习.html">请阅读合同协议</a></td></tr>
					<tr><td>案例主要代码：</td></tr>
					<tr><td>&nbsp;&nbsp;info.onscroll = function(){ //onscroll 滚动条滚动的事件，当元素的滚动条滚动时会触发</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//检查滚动条是否滚动到底</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;if(this.clientHeight == this.scrollHeight - this.scrollTop){</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//当进入判断，则说明滚动条滚动到底了</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//使两个表单项变成可用状态</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//disabled属性用来设置表单项是否禁用</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//设置为true，表示禁用，设置为false表示可用</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;inputs[0].disabled = false;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;inputs[1].disabled = false;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
					<tr><td>&nbsp;&nbsp;};</td></tr>
					<tr><td></td></tr>
				</table>
			</fieldset>
			<!--DOM方法结束-->
			<!--DOM增删改开始-->
			<fieldset id="2">
				<legend>事件对象(event)</legend>
				<table>
					<tr><th>事件对象(event)</th></tr>
					<tr><td></td></tr>
					<tr><td>(1).事件对象：当浏览器在调用事件的响应函数时，每次都会传递一个事件对象作为参数，在事件对象封装了当前事件相关的信息。例如：鼠标的坐标 键盘哪个按键被按下。。。</td></tr>
					<tr><td>(2).event封装了事件对象的信息</td></tr>
					<tr><td>&nbsp;&nbsp;处理event事件兼容性问题：event = event || window.event;</td></tr>
					<tr><td>(3).获取鼠标指针的位置:</td></tr>
					<tr><td>&nbsp;&nbsp; 1.clientX:获取鼠标指针在水平方向的位置</td></tr>
					<tr><td>&nbsp;&nbsp; 2.clientY:获取鼠标指针在垂直方向的位置</td></tr>
					<tr><td>&nbsp;&nbsp; 3.pageX:获取鼠标指针相对于页面的水平坐标,两个属性在IE8及以下的浏览器中并不支持</td></tr>
					<tr><td>&nbsp;&nbsp; 4.pageY:获取鼠标指针相对于页面的垂直坐标 ,两个属性在IE8及以下的浏览器中并不支持</td></tr>
					<tr><td>&nbsp;&nbsp; 用法(获取x轴的位置): var x = event.clientX;</td></tr>
					<tr><td>案例一：<a href="../../实战项目/课堂练习/鼠标移动显示当前移动坐标.html">在区域中移动动态获取鼠标的位置</a></td></tr>
					<tr><td>案例主要代码：</td></tr>
					<tr><td>&nbsp;&nbsp; box.onmousemove = function (event) {</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp; event = event || window.event;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp; var x = event.clientX;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp; var y = event.clientY;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp; box1.innerHTML = "x = "+ x +"，y = "+ y ;</td></tr>
					<tr><td>&nbsp;&nbsp;};</td></tr>
					<tr><td>案例二： <a href="../../实战项目/课堂练习/图片鼠标移动窗口溢出事件.html">div随跟随鼠标进行移动</a></td></tr>
					<tr><td>知识要点:解决浏览器相对定位是根据相对于body还是相对于Html标签的定位</td></tr>
					<tr><td>&nbsp;&nbsp; var sy = document.documentElement.scrollTop || document.body.scrollTop</td></tr>
					<tr><td>案例主要代码：</td></tr>
					<tr><td>&nbsp;&nbsp;document.onmousemove = function (event) {</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//判断浏览器中是否具有event方法</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;event = event || window.event;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//判断浏览器的相对定位是相对于body还是相对于html进行的</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//垂直方向的偏移量</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var sy = document.documentElement.scrollTop || document.body.scrollTop;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//水平方向的偏移量</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var sx = document.documentElement.scrollLeft || document.body.scrollLeft;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//获取鼠标的坐标</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var left = event.clientX + sx;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var top = event.clientY + sy;</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;//将获取的值赋值给box1对象的偏移量（首先要开启定位）</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;box1.style.top = top +"px";</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;box1.style.left = left +"px";</td></tr>
					<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;};</td></tr>
					<tr><td></td></tr>
				</table>
			</fieldset>
			<!--DOM增删改开始结束-->
			<!--DOM案例开始-->
			<fieldset id="3">
				<legend>冒泡（Bubble）</legend>
				<table>
					<tr><th>冒泡（Bubble）</th></tr>
					<tr><td></td></tr>
					<tr><td>(1).冒泡就是事件的向上传导，当后代元素上的事件被触发时，将会导致祖先元素上的相同事件也被触发</td></tr>
					<tr><td>(2).将事件对象的cancelBubble属性设置true，即可取消冒泡;用法： event.cancelBubble = true;(默认是false)</td></tr>
					<tr><td>(3).在HTML中文档的结构没有发生变化时，就算是开启绝对定位使子元素的表现与父元素分离也不会取消冒泡事件，除非HTML文档的结构发生了变化</td></tr>
					<tr><td></td></tr>
				</table>
			</fieldset>
			<!--DOM案例结束-->
		</div>
	</body>
</html>

